namespace FSharpLint.Framework

open FSharp.Compiler.Text

/// Used to walk the FSharp Compiler's abstract syntax tree,
/// so that each node can be visited by a list of visitors.
module Ast =

    open FSharp.Compiler.Syntax


    /// Nodes in the AST to be visited.
    [<NoEquality; NoComparison>]
    type AstNode =
        | Expression of SynExpr
        | Pattern of SynPat
        | SimplePattern of SynSimplePat
        | SimplePatterns of SynSimplePats
        | ModuleOrNamespace of SynModuleOrNamespace
        | ModuleDeclaration of SynModuleDecl
        | Binding of SynBinding
        | TypeDefinition of SynTypeDefn
        | MemberDefinition of SynMemberDefn
        | ComponentInfo of SynComponentInfo
        | ExceptionRepresentation of SynExceptionDefnRepr
        | UnionCase of SynUnionCase
        | EnumCase of SynEnumCase
        | TypeRepresentation of SynTypeDefnRepr
        | TypeSimpleRepresentation of SynTypeDefnSimpleRepr
        | Type of SynType
        | Field of SynField
        | Match of SynMatchClause
        | ConstructorArguments of SynArgPats
        | TypeParameter of SynTypar
        | InterfaceImplementation of SynInterfaceImpl
        | Identifier of string list * range : range
        | File of ParsedInput
        | LambdaBody of SynExpr
        | LambdaArg of SynSimplePats
        | Else of SynExpr

    /// Concatenates the nested-list structure of `SynAttributes` into a `SynAttribute list` to keep other code
    /// mostly unchanged.
    let extractAttributes (attrs:SynAttributes) =
        List.collect (fun (attrList: SynAttributeList) -> attrList.Attributes) attrs

    /// Inlines pipe operators to give a flat function application expression
    /// e.g. `x |> List.map id` to `List.map id x`.
    let (|FuncApp|_|) functionApplication =
        let rec flatten flattened exprToFlatten =
            match exprToFlatten with
            | SynExpr.App(_, _, x, y, _) ->
                match x with
                | SynExpr.App(_, true, SynExpr.LongIdent(_, SynLongIdent([op], _, _), _, _), rhs, _) as app ->
                    let lhs = y

                    match op.idText with
                    | "op_PipeRight" | "op_PipeRight2" | "op_PipeRight3" ->
                        flatten [rhs] lhs
                    | "op_PipeLeft" | "op_PipeLeft2" | "op_PipeLeft3" ->
                        flatten (lhs::flattened) rhs
                    | _ -> flatten (lhs::flattened) app
                | expression ->
                    let leftExpr, rightExpr = (expression, y)
                    flatten (rightExpr::flattened) leftExpr
            | expr -> expr::flattened

        match functionApplication with
        | AstNode.Expression(SynExpr.App(_, _, _, _, range) as functionApplication) ->
            Some(flatten List.Empty functionApplication, range)
        | _ -> None

    [<NoEquality; NoComparison>]
    type Lambda = { Arguments:SynSimplePats list; Body:SynExpr }

    let (|Lambda|_|) lambda =
        /// A match clause is generated by the compiler for each wildcard argument,
        /// this function extracts the body expression of the lambda from those statements.
        let rec removeAutoGeneratedMatchesFromLambda = function
            | SynExpr.Match(DebugPointAtBinding.NoneAtInvisible,
                            _,
                            [SynMatchClause(SynPat.Wild(_), _, expr, _, _, _)], _, _) ->
                removeAutoGeneratedMatchesFromLambda expr
            | synExpr -> synExpr

        let (|IsCurriedLambda|_|) = function
            | SynExpr.Lambda(_, _, parameter, (SynExpr.Lambda(_) as inner), _, _, _) as outer
                    when outer.Range = inner.Range ->
                Some(parameter, inner)
            | _ -> None

        let rec getLambdaParametersAndExpression parameters = function
            | IsCurriedLambda(parameter, curriedLambda) ->
                getLambdaParametersAndExpression (parameter::parameters) curriedLambda
            | SynExpr.Lambda(_, _, parameter, body, _, _, _) ->
                Some
                    {
                        Arguments = parameter :: parameters |> List.rev
                        Body = removeAutoGeneratedMatchesFromLambda body
                    }
            | _ -> None

        match lambda with
        | AstNode.Expression(SynExpr.Lambda(_, _, _, _, _, range, _) as lambda) ->
            getLambdaParametersAndExpression List.Empty lambda
            |> Option.map (fun lambdaExprs -> (lambdaExprs, range))
        | _ -> None

    let (|Cons|_|) pattern =
        match pattern with
        | SynPat.ListCons(lhs, rhs, _, _) ->
            Some(lhs, rhs)
        | SynPat.LongIdent(SynLongIdent([identifier], _, _),
                           _, _,
                           SynArgPats.Pats([SynPat.Tuple(_, [lhs; rhs], _, _)]), _, _)
                when identifier.idText = "op_ColonColon" ->
            Some(lhs, rhs)
        | _ -> None

    /// Gets a string literal from the AST.
    let (|StringLiteral|_|) node =
        match node with
        | Expression(SynExpr.Const(SynConst.String(value, _, _), range)) -> Some(value, range)
        | _ -> None

    module List =
        let inline revIter action items =
            items |> List.rev |> List.iter action

    let inline private moduleDeclarationChildren node add =
        match node with
        | SynModuleDecl.NestedModule(componentInfo, _, moduleDeclarations, _, _, _) ->
            List.revIter (ModuleDeclaration >> add) moduleDeclarations
            add <| ComponentInfo componentInfo
        | SynModuleDecl.Let(_, bindings, _) -> List.revIter (Binding >> add) bindings
        | SynModuleDecl.Expr(expression, _) -> add <| Expression expression
        | SynModuleDecl.Types(typeDefinitions, _) -> List.revIter (TypeDefinition >> add) typeDefinitions
        | SynModuleDecl.Exception(SynExceptionDefn.SynExceptionDefn(repr, _, members, _), _) ->
            List.revIter (MemberDefinition >> add) members
            add <| ExceptionRepresentation repr
        | SynModuleDecl.NamespaceFragment(moduleOrNamespace) -> add <| ModuleOrNamespace moduleOrNamespace
        | SynModuleDecl.Open(_)
        | SynModuleDecl.Attributes(_)
        | SynModuleDecl.HashDirective(_)
        | SynModuleDecl.ModuleAbbrev(_) -> ()

    let inline private typeChildren node add =
        match node with
        | SynType.LongIdentApp(synType, _, _, types, _, _, _)
        | SynType.App(synType, _, types, _, _, _, _) ->
            types |> List.revIter (Type >> add)
            add <| Type synType
        | SynType.Tuple(_, types, _) ->
            types |> List.revIter (function
                | SynTupleTypeSegment.Type(synType) -> add <| Type synType
                | SynTupleTypeSegment.Slash(_) -> ()
                | SynTupleTypeSegment.Star(_) -> ())
        | SynType.Fun(synType, synType1, _, _) ->
            add <| Type synType1
            add <| Type synType
        | SynType.StaticConstantNamed(synType, synType1, _) ->
            add <| Type synType1
            add <| Type synType
        | SynType.Var(_)
        | SynType.Anon(_)
        | SynType.LongIdent(_)
        | SynType.StaticConstant(_)
        | SynType.StaticConstantNull(_)
        | SynType.FromParseError(_) -> ()
        | SynType.WithGlobalConstraints(synType, _, _)
        | SynType.HashConstraint(synType, _)
        | SynType.MeasurePower(synType, _, _)
        | SynType.Array(_, synType, _) -> add <| Type synType
        | SynType.StaticConstantExpr(expression, _) -> add <| Expression expression
        | SynType.AnonRecd (_, typeNames, _) ->
            List.revIter (snd >> Type >> add) typeNames
        | SynType.Paren(innerType, _) ->
            add <| Type innerType
        | SynType.Intersection(synTyparOpt, types, _, _) ->
            synTyparOpt |> Option.iter (TypeParameter >> add)
            types |> List.revIter (Type >> add)
        | SynType.Or(synType, synType1, _, _) ->
            add <| Type synType
            add <| Type synType1
        | SynType.SignatureParameter(_, _, _, synType, _) ->
            add <| Type synType
        | SynType.WithNull(synType, _, _, _) ->
            add <| Type synType

    /// Concatenates the typed-or-untyped structure of `SynSimplePats` into a `SynSimplePat list` to keep other code
    /// mostly unchanged.
    let inline extractPatterns (simplePats:SynSimplePats) =
        match simplePats with
        | SynSimplePats.SimplePats(patterns, _, _) -> patterns

    let inline private memberDefinitionChildren node add =
        match node with
        | SynMemberDefn.Member(binding, _) -> add <| Binding binding
        | SynMemberDefn.ImplicitCtor(_, _, patterns, _, _, _, _) ->
            add <| Pattern patterns
        | SynMemberDefn.ImplicitInherit(synType, expression, _, _, _) ->
            add <| Expression expression
            add <| Type synType
        | SynMemberDefn.LetBindings(bindings, _, _, _) -> List.revIter (Binding >> add) bindings
        | SynMemberDefn.Interface(synType, _, Some(members), _) ->
            List.revIter (MemberDefinition >> add) members
            add <| Type synType
        | SynMemberDefn.Interface(synType, _, None, _)
        | SynMemberDefn.Inherit(Some synType, _, _, _) -> add <| Type synType
        | SynMemberDefn.Inherit(None, _, _, _)
        | SynMemberDefn.Open(_)
        | SynMemberDefn.AbstractSlot(_) -> ()
        | SynMemberDefn.ValField(field, _) -> add <| Field field
        | SynMemberDefn.NestedType(typeDefinition, _, _) -> add <| TypeDefinition typeDefinition
        | SynMemberDefn.AutoProperty(_, _, _, Some(synType), _, _, _, _, _, expression, _, _) ->
            add <| Expression expression
            add <| Type synType
        | SynMemberDefn.AutoProperty(_, _, _, None, _, _, _, _, _, expression, _, _) ->
            add <| Expression expression
        | SynMemberDefn.GetSetMember(memberDefnForGet, memberDefnForSet, _, _) ->
            Option.iter (Binding >> add) memberDefnForGet
            Option.iter (Binding >> add) memberDefnForSet

    let inline private patternChildren node add =
        match node with
        | SynPat.IsInst(synType, _) -> add <| Type synType
        | SynPat.QuoteExpr(expression, _) -> add <| Expression expression
        | SynPat.Typed(pattern, synType, _) ->
            add <| Type synType
            add <| Pattern pattern
        | SynPat.Or(pattern, pattern1, _, _) ->
            add <| Pattern pattern1
            add <| Pattern pattern
        | SynPat.ArrayOrList(_, patterns, _)
        | SynPat.Tuple(_, patterns, _, _)
        | SynPat.Ands(patterns, _) -> patterns |> List.revIter (Pattern >> add)
        | SynPat.Attrib(pattern, _, _)
        | SynPat.Paren(pattern, _) -> add <| Pattern pattern
        | SynPat.Named(_) -> ()
        | SynPat.Record(patPairFieldList, _) -> patPairFieldList |> List.revIter(_.Pattern >> Pattern >> add)
        | SynPat.Const(_)
        | SynPat.Wild(_)
        | SynPat.FromParseError(_)
        | SynPat.InstanceMember(_)
        | SynPat.Null(_)
        | SynPat.OptionalVal(_) -> ()
        | Cons(lhs, rhs) ->
            add <| Pattern rhs
            add <| Pattern lhs
        | SynPat.LongIdent(_, _, _, constructorArguments, _, _) ->
            add <| ConstructorArguments constructorArguments
        | SynPat.As(lhsPart, rhsPart, _) ->
            add <| Pattern lhsPart
            add <| Pattern rhsPart
        | SynPat.ListCons(lhs, rhs, _, _) ->
            add <| Pattern lhs
            add <| Pattern rhs


    // fsharplint:disable FL0025
    let inline private expressionChildren (node: SynExpr) (add: AstNode -> unit) =
        let addMany = List.iter add

        match node with
        | SynExpr.Paren(expression, _, _, _)
        | SynExpr.DotGet(expression, _, _, _)
        | SynExpr.DotIndexedGet(expression, _, _, _)
        | SynExpr.LongIdentSet(_, expression, _)
        | SynExpr.Do(expression, _)
        | SynExpr.Assert(expression, _)
        | SynExpr.ComputationExpr(_, expression, _)
        | SynExpr.ArrayOrListComputed(_, expression, _)
        | SynExpr.AddressOf(_, expression, _, _)
        | SynExpr.InferredDowncast(expression, _)
        | SynExpr.InferredUpcast(expression, _)
        | SynExpr.DoBang(expression, _, _)
        | SynExpr.Lazy(expression, _)
        | SynExpr.TraitCall(_, _, expression, _)
        | SynExpr.YieldOrReturn(_, expression, _, _)
        | SynExpr.YieldOrReturnFrom(_, expression, _, _) -> add <| Expression expression
        | SynExpr.SequentialOrImplicitYield(_, expression1, expression2, ifNotExpression, _) ->
            addMany [Expression expression1; Expression expression2; Expression ifNotExpression]
        | SynExpr.Quote(expression, _, expression1, _, _)
        | SynExpr.Sequential(_, _, expression, expression1, _, _)
        | SynExpr.NamedIndexedPropertySet(_, expression, expression1, _)
        | SynExpr.DotIndexedSet(expression, _, expression1, _, _, _)
        | SynExpr.JoinIn(expression, _, expression1, _)
        | SynExpr.While(_, expression, expression1, _)
        | SynExpr.TryFinally(expression, expression1, _, _, _, _)
        | SynExpr.Set(expression, expression1, _)
        | SynExpr.DotSet(expression, _, expression1, _) ->
            addMany [Expression expression1; Expression expression]
        | SynExpr.Typed(expression, synType, _) ->
            addMany [Type synType; Expression expression]
        | SynExpr.Tuple(_, expressions, _, _)
        | SynExpr.ArrayOrList(_, expressions, _) -> List.revIter (Expression >> add) expressions
        | SynExpr.Record(_, Some(expr, _), _, _) -> add <| Expression expr
        | SynExpr.Record(_, None, _, _) -> ()
        | SynExpr.AnonRecd(_, Some (expr,_), _, _, _) ->
            add <| Expression expr
        | SynExpr.AnonRecd(_, None, _, _, _) -> ()
        | SynExpr.ObjExpr(synType, _, _, bindings, _, _, _, _) ->
            List.revIter (Binding >> add) bindings
            add <| Type synType
        | SynExpr.DotNamedIndexedPropertySet(expression, _, expression1, expression2, _)
        | SynExpr.For(_, _, _, _, expression, _, expression1, expression2, _) ->
            addMany [Expression expression2; Expression expression1; Expression expression]
        | SynExpr.ForEach(_, _, _, _, pattern, expression, expression1, _) ->
            addMany [Expression expression1; Expression expression; Pattern pattern]
        | SynExpr.MatchLambda(_, _, matchClauses, _, _) ->
            List.revIter (Match >> add) matchClauses
        | SynExpr.TryWith(expression, matchClauses, _, _, _, _)
        | SynExpr.MatchBang(_, expression, matchClauses, _, _)
        | SynExpr.Match(_, expression, matchClauses, _, _) ->
            List.revIter (Match >> add) matchClauses
            add <| Expression expression
        | SynExpr.TypeApp(expression, _, types, _, _, _, _) ->
            List.revIter (Type >> add) types
            add <| Expression expression
        | SynExpr.New(_, synType, expression, _)
        | SynExpr.TypeTest(expression, synType, _)
        | SynExpr.Upcast(expression, synType, _)
        | SynExpr.Downcast(expression, synType, _) ->
            addMany [Type synType; Expression expression]
        // regular let or use
        | SynExpr.LetOrUse(_, _, _, false, bindings, expression, _, _) ->
            add <| Expression expression
            List.revIter (Binding >> add) bindings
        // let! or use!
        | SynExpr.LetOrUse(_, _, _, true, bindings, leftHandSide, _, _) ->
            match bindings with
            | firstBinding :: andBangs ->
                match firstBinding with
                | SynBinding(headPat = pattern; expr = rightHandSide) ->
                    addMany [Expression rightHandSide; Expression leftHandSide]
                    List.iter (fun (SynBinding(headPat = pattern; expr = body)) ->
                        addMany [Expression body; Pattern pattern]
                    ) andBangs
                    add <| Pattern pattern
            | [] -> () // error case. @@TODO@@ any other handling needed here?
        | SynExpr.Ident(ident) -> add <| Identifier([ident.idText], ident.idRange)
        | SynExpr.LongIdent(_, SynLongIdent(ident, _, _), _, range) ->
            add <| Identifier(List.map (fun (identifier: Ident) -> identifier.idText) ident, range)
        | SynExpr.IfThenElse(cond, body, Some(elseExpr), _, _, _, _) ->
            addMany [Else elseExpr; Expression body; Expression cond]
        | SynExpr.IfThenElse(cond, body, None, _, _, _, _) ->
            addMany [Expression body; Expression cond]
        | SynExpr.InterpolatedString(contents, _, range) -> 
            List.iter (
                function
                    | SynInterpolatedStringPart.String _ -> ()
                    | SynInterpolatedStringPart.FillExpr (expr, _ident) -> add <| Expression expr
                )
                contents
        (*
        | SynExpr.ImplicitZero(_)
        | SynExpr.Null(_)
        | SynExpr.Const(_)
        | SynExpr.DiscardAfterMissingQualificationAfterDot(_)
        | SynExpr.FromParseError(_)
        | SynExpr.LibraryOnlyILAssembly(_)
        | SynExpr.LibraryOnlyStaticOptimization(_)
        | SynExpr.LibraryOnlyUnionCaseFieldGet(_)
        | SynExpr.LibraryOnlyUnionCaseFieldSet(_)
        | SynExpr.ArbitraryAfterError(_)
        | SynExpr.Lambda(_)
        | SynExpr.DotLambda(_)
        | SynExpr.App(_)
        | SynExpr.Fixed(_) -> ()
        *)
        | SynExpr.Typar(_) -> ()
        | SynExpr.WhileBang(_, expression, expression1, _) ->
            add <| Expression expression1
            add <| Expression expression
        | SynExpr.DebugPoint(_debugPoint, _, innerExpr) -> 
            add <| Expression innerExpr
        | SynExpr.Dynamic(funcExpr, _, argExpr, _) ->
            addMany [Expression funcExpr; Expression argExpr]
        | SynExpr.IndexFromEnd(expr, _) -> 
            add <| Expression expr
        | SynExpr.IndexRange(expr1, _, expr2, _, _, _) ->
            expr1 |> Option.iter (Expression >> add)
            expr2 |> Option.iter (Expression >> add)
        | _ -> ()

    // fsharplint:enable

    let inline private typeSimpleRepresentationChildren node add =
        match node with
        | SynTypeDefnSimpleRepr.Union(_, unionCases, _) -> List.revIter (UnionCase >> add) unionCases
        | SynTypeDefnSimpleRepr.Enum(enumCases, _) -> List.revIter (EnumCase >> add) enumCases
        | SynTypeDefnSimpleRepr.Record(_, fields, _) -> List.revIter (Field >> add) fields
        | SynTypeDefnSimpleRepr.TypeAbbrev(_, synType, _) -> add <| Type synType
        | SynTypeDefnSimpleRepr.Exception(exceptionRepr) -> add <| ExceptionRepresentation exceptionRepr
        | SynTypeDefnSimpleRepr.General(_)
        | SynTypeDefnSimpleRepr.LibraryOnlyILAssembly(_)
        | SynTypeDefnSimpleRepr.None(_) -> ()

    let inline private simplePatternsChildren node add =
        match node with
        | SynSimplePats.SimplePats(simplePatterns, _, _) ->
            simplePatterns |> List.revIter (SimplePattern >> add)

    let inline private simplePatternChildren node add =
        match node with
        | SynSimplePat.Typed(simplePattern, synType, _) ->
            add <| Type synType
            add <| SimplePattern simplePattern
        | SynSimplePat.Attrib(simplePattern, _, _) -> add <| SimplePattern simplePattern
        | SynSimplePat.Id(identifier, _, _, _, _, _) -> add <| Identifier([identifier.idText], identifier.idRange)

    let inline private matchChildren node add =
        match node with
        | SynMatchClause(pattern, Some(expression), expression1, _, _, _) ->
            add <| Expression expression1
            add <| Expression expression
            add <| Pattern pattern
        | SynMatchClause(pattern, None, expression1, _, _, _) ->
            add <| Expression expression1
            add <| Pattern pattern

    let inline private constructorArgumentsChildren node add =
        match node with
        | SynArgPats.Pats(patterns) ->
            patterns |> List.revIter (Pattern >> add)
        | SynArgPats.NamePatPairs(namePatterns, _, _) ->
            namePatterns |> List.revIter (_.Pattern >> Pattern >> add)

    let inline private typeRepresentationChildren node add =
        match node with
        | SynTypeDefnRepr.ObjectModel(_, members, _) ->
            List.revIter (MemberDefinition >> add) members
        | SynTypeDefnRepr.Simple(typeSimpleRepresentation, _) ->
            add <| TypeSimpleRepresentation typeSimpleRepresentation
        | SynTypeDefnRepr.Exception(exceptionRepr) ->
            add <| ExceptionRepresentation exceptionRepr

    let inline private unionCaseChildren node add =
        match node with
        | SynUnionCase(caseType=(SynUnionCaseKind.Fields fields)) ->
            List.revIter (Field >> add) fields
        | SynUnionCase(caseType=(SynUnionCaseKind.FullType (fullType, _))) ->
            add (Type fullType)

    /// Extracts the child nodes to be visited from a given node.
    let traverseNode node add =
        match node with
        | ModuleDeclaration(moduleDecl) -> moduleDeclarationChildren moduleDecl add
        | ModuleOrNamespace(SynModuleOrNamespace(_, _, _, moduleDeclarations, _, _, _, _, _)) ->
            List.revIter (ModuleDeclaration >> add) moduleDeclarations
        | Binding(SynBinding(_, _, _, _, _, _, _, pattern, _, expression, _, _, _)) ->
            add <| Expression expression
            add <| Pattern pattern
        | ExceptionRepresentation(SynExceptionDefnRepr.SynExceptionDefnRepr(_, unionCase, _, _, _, _)) ->
            add <| UnionCase unionCase
        | TypeDefinition(SynTypeDefn(componentInfo, typeRepresentation, members, implicitCtor, _, _)) ->
            Option.iter (MemberDefinition >> add) implicitCtor
            List.revIter (MemberDefinition >> add) members
            add <| TypeRepresentation typeRepresentation
            add <| ComponentInfo componentInfo
        | TypeSimpleRepresentation(value) -> typeSimpleRepresentationChildren value add
        | Type(value) -> typeChildren value add
        | Match(value) -> matchChildren value add
        | MemberDefinition(value) -> memberDefinitionChildren value add
        | Field(SynField(_, _, _, synType, _, _, _, _, _)) -> add <| Type synType
        | Pattern(value) -> patternChildren value add
        | ConstructorArguments(value) -> constructorArgumentsChildren value add
        | SimplePattern(value) -> simplePatternChildren value add
        | LambdaArg(value)
        | SimplePatterns(value) -> simplePatternsChildren value add
        | InterfaceImplementation(SynInterfaceImpl(synType, _, bindings, _, _)) ->
            List.revIter (Binding >> add) bindings
            add <| Type synType
        | TypeRepresentation value -> typeRepresentationChildren value add
        | FuncApp(exprs, _) -> List.revIter (Expression >> add) exprs
        | Lambda({ Arguments = args; Body = body }, _) ->
            add <| LambdaBody(body)
            args |> List.revIter (LambdaArg >> add)

        | LambdaBody(expression)
        | Else(expression)
        | Expression(expression) -> expressionChildren expression add

        | File(ParsedInput.ImplFile(ParsedImplFileInput(contents = moduleOrNamespaces))) ->
            moduleOrNamespaces |> List.revIter (ModuleOrNamespace >> add)

        | UnionCase(unionCase) -> unionCaseChildren unionCase add
        | File(ParsedInput.SigFile(_))
        | ComponentInfo(_)
        | EnumCase(_)
        | Identifier(_)
        | TypeParameter(_) -> ()
